{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _fastEquals = require(\"fast-equals\");\n\nvar _clsx = _interopRequireDefault(require(\"clsx\"));\n\nvar _utils = require(\"./utils\");\n\nvar _calculateUtils = require(\"./calculateUtils\");\n\nvar _GridItem = _interopRequireDefault(require(\"./GridItem\"));\n\nvar _ReactGridLayoutPropTypes = _interopRequireDefault(require(\"./ReactGridLayoutPropTypes\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n\n/*:: import type {\n  CompactType,\n  GridResizeEvent,\n  GridDragEvent,\n  DragOverEvent,\n  Layout,\n  DroppingPosition,\n  LayoutItem\n} from \"./utils\";*/\n// Types\n\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n\n/*:: type State = {\n  activeDrag: ?LayoutItem,\n  layout: Layout,\n  mounted: boolean,\n  oldDragItem: ?LayoutItem,\n  oldLayout: ?Layout,\n  oldResizeItem: ?LayoutItem,\n  resizing: boolean,\n  droppingDOMNode: ?ReactElement<any>,\n  droppingPosition?: DroppingPosition,\n  // Mirrored props\n  children: ReactChildrenArray<ReactElement<any>>,\n  compactType?: CompactType,\n  propsLayout?: Layout\n};*/\n\n/*:: import type { Props, DefaultProps } from \"./ReactGridLayoutPropTypes\";*/\n// End Types\n\n\nconst layoutClassName = \"react-grid-layout\";\nlet isFirefox = false; // Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\n\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch (e) {\n  /* Ignore */\n}\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\n\nclass ReactGridLayout extends React.Component\n/*:: <Props, State>*/\n{\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"state\", {\n      activeDrag: null,\n      layout: (0, _utils.synchronizeLayoutWithChildren)(this.props.layout, this.props.children, this.props.cols, // Legacy support for verticalCompact: false\n      (0, _utils.compactType)(this.props), this.props.allowOverlap),\n      mounted: false,\n      oldDragItem: null,\n      oldLayout: null,\n      oldResizeItem: null,\n      resizing: false,\n      droppingDOMNode: null,\n      children: []\n    });\n\n    _defineProperty(this, \"dragEnterCounter\", 0);\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n\n\n    _defineProperty(this, \"onDragStart\", (i\n    /*: string*/\n    , x\n    /*: number*/\n    , y\n    /*: number*/\n    , _ref\n    /*:: */\n    ) => {\n      let {\n        e,\n        node\n      }\n      /*: GridDragEvent*/\n      = _ref\n      /*: GridDragEvent*/\n      ;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldDragItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: layout\n      });\n      return this.props.onDragStart(layout, l, l, null, e, node);\n    });\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n\n\n    _defineProperty(this, \"onDrag\", (i, x, y, _ref2) => {\n      let {\n        e,\n        node\n      } = _ref2;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        allowOverlap,\n        preventCollision\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return; // Create placeholder (display only)\n\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      }; // Move the element to the dragged location.\n\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n      this.setState({\n        layout: allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n\n\n    _defineProperty(this, \"onDragStop\", (i, x, y, _ref3) => {\n      let {\n        e,\n        node\n      } = _ref3;\n      if (!this.state.activeDrag) return;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return; // Move the element here\n\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap); // Set state\n\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onDragStop(newLayout, oldDragItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldDragItem: null,\n        oldLayout: null\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n\n    _defineProperty(this, \"onResizeStart\", (i, w, h, _ref4) => {\n      let {\n        e,\n        node\n      } = _ref4;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldResizeItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: this.state.layout,\n        resizing: true\n      });\n      this.props.onResizeStart(layout, l, l, null, e, node);\n    });\n\n    _defineProperty(this, \"onResize\", (i, w, h, _ref5) => {\n      let {\n        e,\n        node,\n        size,\n        handle\n      } = _ref5;\n      const {\n        oldResizeItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      let shouldMoveItem = false;\n      let finalLayout;\n      let x;\n      let y;\n      const [newLayout, l] = (0, _utils.withLayoutItem)(layout, i, l => {\n        let hasCollisions;\n        x = l.x;\n        y = l.y;\n\n        if ([\"sw\", \"w\", \"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n          if ([\"sw\", \"nw\", \"w\"].indexOf(handle) !== -1) {\n            x = l.x + (l.w - w);\n            w = l.x !== x && x < 0 ? l.w : w;\n            x = x < 0 ? 0 : x;\n          }\n\n          if ([\"ne\", \"n\", \"nw\"].indexOf(handle) !== -1) {\n            y = l.y + (l.h - h);\n            h = l.y !== y && y < 0 ? l.h : h;\n            y = y < 0 ? 0 : y;\n          }\n\n          shouldMoveItem = true;\n        } // Something like quad tree should be used\n        // to find collisions faster\n\n\n        if (preventCollision && !allowOverlap) {\n          const collisions = (0, _utils.getAllCollisions)(layout, { ...l,\n            w,\n            h,\n            x,\n            y\n          }).filter(layoutItem => layoutItem.i !== l.i);\n          hasCollisions = collisions.length > 0; // If we're colliding, we need adjust the placeholder.\n\n          if (hasCollisions) {\n            // Reset layoutItem dimensions if there were collisions\n            y = l.y;\n            h = l.h;\n            x = l.x;\n            w = l.w;\n            shouldMoveItem = false;\n          }\n        }\n\n        l.w = w;\n        l.h = h;\n        return l;\n      }); // Shouldn't ever happen, but typechecking makes it necessary\n\n      if (!l) return;\n      finalLayout = newLayout;\n\n      if (shouldMoveItem) {\n        // Move the element to the new position.\n        const isUserAction = true;\n        finalLayout = (0, _utils.moveElement)(newLayout, l, x, y, isUserAction, this.props.preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      } // Create placeholder element (display only)\n\n\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        static: true,\n        i: i\n      };\n      this.props.onResize(finalLayout, oldResizeItem, l, placeholder, e, node); // Re-compact the newLayout and set the drag placeholder.\n\n      this.setState({\n        layout: allowOverlap ? finalLayout : (0, _utils.compact)(finalLayout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n\n    _defineProperty(this, \"onResizeStop\", (i, w, h, _ref6) => {\n      let {\n        e,\n        node\n      } = _ref6;\n      const {\n        layout,\n        oldResizeItem\n      } = this.state;\n      const {\n        cols,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i); // Set state\n\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onResizeStop(newLayout, oldResizeItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldResizeItem: null,\n        oldLayout: null,\n        resizing: false\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }); // Called while dragging an element. Part of browser native drag/drop API.\n    // Native event target might be the layout itself, or an element within the layout.\n\n\n    _defineProperty(this, \"onDragOver\", e => {\n      var _e$nativeEvent$target;\n\n      e.preventDefault(); // Prevent any browser native action\n\n      e.stopPropagation(); // we should ignore events from layout's children in Firefox\n      // to avoid unpredictable jumping of a dropping placeholder\n      // FIXME remove this hack\n\n      if (isFirefox && // $FlowIgnore can't figure this out\n      !((_e$nativeEvent$target = e.nativeEvent.target) !== null && _e$nativeEvent$target !== void 0 && _e$nativeEvent$target.classList.contains(layoutClassName))) {\n        return false;\n      }\n\n      const {\n        droppingItem,\n        onDropDragOver,\n        margin,\n        cols,\n        rowHeight,\n        maxRows,\n        width,\n        containerPadding,\n        transformScale\n      } = this.props; // Allow user to customize the dropping item or short-circuit the drop based on the results\n      // of the `onDragOver(e: Event)` callback.\n\n      const onDragOverResult = onDropDragOver === null || onDropDragOver === void 0 ? void 0 : onDropDragOver(e);\n\n      if (onDragOverResult === false) {\n        if (this.state.droppingDOMNode) {\n          this.removeDroppingPlaceholder();\n        }\n\n        return false;\n      }\n\n      const finalDroppingItem = { ...droppingItem,\n        ...onDragOverResult\n      };\n      const {\n        layout\n      } = this.state; // This is relative to the DOM element that this event fired for.\n\n      const {\n        layerX,\n        layerY\n      } = e.nativeEvent;\n      const droppingPosition = {\n        left: layerX / transformScale,\n        top: layerY / transformScale,\n        e\n      };\n\n      if (!this.state.droppingDOMNode) {\n        const positionParams\n        /*: PositionParams*/\n        = {\n          cols,\n          margin,\n          maxRows,\n          rowHeight,\n          containerWidth: width,\n          containerPadding: containerPadding || margin\n        };\n        const calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);\n        this.setState({\n          droppingDOMNode: /*#__PURE__*/React.createElement(\"div\", {\n            key: finalDroppingItem.i\n          }),\n          droppingPosition,\n          layout: [...layout, { ...finalDroppingItem,\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            static: false,\n            isDraggable: true\n          }]\n        });\n      } else if (this.state.droppingPosition) {\n        const {\n          left,\n          top\n        } = this.state.droppingPosition;\n        const shouldUpdatePosition = left != layerX || top != layerY;\n\n        if (shouldUpdatePosition) {\n          this.setState({\n            droppingPosition\n          });\n        }\n      }\n    });\n\n    _defineProperty(this, \"removeDroppingPlaceholder\", () => {\n      const {\n        droppingItem,\n        cols\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const newLayout = (0, _utils.compact)(layout.filter(l => l.i !== droppingItem.i), (0, _utils.compactType)(this.props), cols, this.props.allowOverlap);\n      this.setState({\n        layout: newLayout,\n        droppingDOMNode: null,\n        activeDrag: null,\n        droppingPosition: undefined\n      });\n    });\n\n    _defineProperty(this, \"onDragLeave\", e => {\n      e.preventDefault(); // Prevent any browser native action\n\n      e.stopPropagation();\n      this.dragEnterCounter--; // onDragLeave can be triggered on each layout's child.\n      // But we know that count of dragEnter and dragLeave events\n      // will be balanced after leaving the layout's container\n      // so we can increase and decrease count of dragEnter and\n      // when it'll be equal to 0 we'll remove the placeholder\n\n      if (this.dragEnterCounter === 0) {\n        this.removeDroppingPlaceholder();\n      }\n    });\n\n    _defineProperty(this, \"onDragEnter\", e => {\n      e.preventDefault(); // Prevent any browser native action\n\n      e.stopPropagation();\n      this.dragEnterCounter++;\n    });\n\n    _defineProperty(this, \"onDrop\", (e\n    /*: Event*/\n    ) => {\n      e.preventDefault(); // Prevent any browser native action\n\n      e.stopPropagation();\n      const {\n        droppingItem\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const item = layout.find(l => l.i === droppingItem.i); // reset dragEnter counter on drop\n\n      this.dragEnterCounter = 0;\n      this.removeDroppingPlaceholder();\n      this.props.onDrop(layout, item, e);\n    });\n  }\n\n  componentDidMount() {\n    this.setState({\n      mounted: true\n    }); // Possibly call back with layout on mount. This should be done after correcting the layout width\n    // to ensure we don't rerender with the wrong width.\n\n    this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n  }\n\n  static getDerivedStateFromProps(nextProps\n  /*: Props*/\n  , prevState\n  /*: State*/\n  )\n  /*: $Shape<State> | null*/\n  {\n    let newLayoutBase;\n\n    if (prevState.activeDrag) {\n      return null;\n    } // Legacy support for compactType\n    // Allow parent to set layout directly.\n\n\n    if (!(0, _fastEquals.deepEqual)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {\n      newLayoutBase = nextProps.layout;\n    } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {\n      // If children change, also regenerate the layout. Use our state\n      // as the base in case because it may be more up to date than\n      // what is in props.\n      newLayoutBase = prevState.layout;\n    } // We need to regenerate the layout.\n\n\n    if (newLayoutBase) {\n      const newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);\n      return {\n        layout: newLayout,\n        // We need to save these props to state for using\n        // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n        compactType: nextProps.compactType,\n        children: nextProps.children,\n        propsLayout: nextProps.layout\n      };\n    }\n\n    return null;\n  }\n\n  shouldComponentUpdate(nextProps\n  /*: Props*/\n  , nextState\n  /*: State*/\n  )\n  /*: boolean*/\n  {\n    return (// NOTE: this is almost always unequal. Therefore the only way to get better performance\n      // from SCU is if the user intentionally memoizes children. If they do, and they can\n      // handle changes properly, performance will increase.\n      this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _fastEquals.deepEqual) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition\n    );\n  }\n\n  componentDidUpdate(prevProps\n  /*: Props*/\n  , prevState\n  /*: State*/\n  ) {\n    if (!this.state.activeDrag) {\n      const newLayout = this.state.layout;\n      const oldLayout = prevState.layout;\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n  }\n  /**\n   * Calculates a pixel value for the container.\n   * @return {String} Container height in pixels.\n   */\n\n\n  containerHeight()\n  /*: ?string*/\n  {\n    if (!this.props.autoSize) return;\n    const nbRow = (0, _utils.bottom)(this.state.layout);\n    const containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];\n    return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + \"px\";\n  }\n\n  onLayoutMaybeChanged(newLayout\n  /*: Layout*/\n  , oldLayout\n  /*: ?Layout*/\n  ) {\n    if (!oldLayout) oldLayout = this.state.layout;\n\n    if (!(0, _fastEquals.deepEqual)(oldLayout, newLayout)) {\n      this.props.onLayoutChange(newLayout);\n    }\n  }\n  /**\n   * Create a placeholder object.\n   * @return {Element} Placeholder div.\n   */\n\n\n  placeholder()\n  /*: ?ReactElement<any>*/\n  {\n    const {\n      activeDrag\n    } = this.state;\n    if (!activeDrag) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      useCSSTransforms,\n      transformScale\n    } = this.props; // {...this.state.activeDrag} is pretty slow, actually\n\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      w: activeDrag.w,\n      h: activeDrag.h,\n      x: activeDrag.x,\n      y: activeDrag.y,\n      i: activeDrag.i,\n      className: \"react-grid-placeholder \".concat(this.state.resizing ? \"placeholder-resizing\" : \"\"),\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      isDraggable: false,\n      isResizable: false,\n      isBounded: false,\n      useCSSTransforms: useCSSTransforms,\n      transformScale: transformScale\n    }, /*#__PURE__*/React.createElement(\"div\", null));\n  }\n  /**\n   * Given a grid item, set its style attributes & surround in a <Draggable>.\n   * @param  {Element} child React element.\n   * @return {Element}       Element wrapped in draggable and properly placed.\n   */\n\n\n  processGridItem(child\n  /*: ReactElement<any>*/\n  , isDroppingItem\n  /*: boolean*/\n  )\n  /*: ?ReactElement<any>*/\n  {\n    if (!child || !child.key) return;\n    const l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));\n    if (!l) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      isDraggable,\n      isResizable,\n      isBounded,\n      useCSSTransforms,\n      transformScale,\n      draggableCancel,\n      draggableHandle,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const {\n      mounted,\n      droppingPosition\n    } = this.state; // Determine user manipulations possible.\n    // If an item is static, it can't be manipulated by default.\n    // Any properties defined directly on the grid item will take precedence.\n\n    const draggable = typeof l.isDraggable === \"boolean\" ? l.isDraggable : !l.static && isDraggable;\n    const resizable = typeof l.isResizable === \"boolean\" ? l.isResizable : !l.static && isResizable;\n    const resizeHandlesOptions = l.resizeHandles || resizeHandles; // isBounded set on child if set on parent, and child is not explicitly false\n\n    const bounded = draggable && isBounded && l.isBounded !== false;\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      cancel: draggableCancel,\n      handle: draggableHandle,\n      onDragStop: this.onDragStop,\n      onDragStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onResizeStart: this.onResizeStart,\n      onResize: this.onResize,\n      onResizeStop: this.onResizeStop,\n      isDraggable: draggable,\n      isResizable: resizable,\n      isBounded: bounded,\n      useCSSTransforms: useCSSTransforms && mounted,\n      usePercentages: !mounted,\n      transformScale: transformScale,\n      w: l.w,\n      h: l.h,\n      x: l.x,\n      y: l.y,\n      i: l.i,\n      minH: l.minH,\n      minW: l.minW,\n      maxH: l.maxH,\n      maxW: l.maxW,\n      static: l.static,\n      droppingPosition: isDroppingItem ? droppingPosition : undefined,\n      resizeHandles: resizeHandlesOptions,\n      resizeHandle: resizeHandle\n    }, child);\n  }\n\n  render()\n  /*: React.Element<\"div\">*/\n  {\n    const {\n      className,\n      style,\n      isDroppable,\n      innerRef\n    } = this.props;\n    const mergedClassName = (0, _clsx.default)(layoutClassName, className);\n    const mergedStyle = {\n      height: this.containerHeight(),\n      ...style\n    };\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: innerRef,\n      className: mergedClassName,\n      style: mergedStyle,\n      onDrop: isDroppable ? this.onDrop : _utils.noop,\n      onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,\n      onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,\n      onDragOver: isDroppable ? this.onDragOver : _utils.noop\n    }, React.Children.map(this.props.children, child => this.processGridItem(child)), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());\n  }\n\n}\n\nexports.default = ReactGridLayout; // TODO publish internal ReactClass displayName transform\n\n_defineProperty(ReactGridLayout, \"displayName\", \"ReactGridLayout\"); // Refactored to another module to make way for preval\n\n\n_defineProperty(ReactGridLayout, \"propTypes\", _ReactGridLayoutPropTypes.default);\n\n_defineProperty(ReactGridLayout, \"defaultProps\", {\n  autoSize: true,\n  cols: 12,\n  className: \"\",\n  style: {},\n  draggableHandle: \"\",\n  draggableCancel: \"\",\n  containerPadding: null,\n  rowHeight: 150,\n  maxRows: Infinity,\n  // infinite vertical growth\n  layout: [],\n  margin: [10, 10],\n  isBounded: false,\n  isDraggable: true,\n  isResizable: true,\n  allowOverlap: false,\n  isDroppable: false,\n  useCSSTransforms: true,\n  transformScale: 1,\n  verticalCompact: true,\n  compactType: \"vertical\",\n  preventCollision: false,\n  droppingItem: {\n    i: \"__dropping-elem__\",\n    h: 1,\n    w: 1\n  },\n  resizeHandles: [\"se\"],\n  onLayoutChange: _utils.noop,\n  onDragStart: _utils.noop,\n  onDrag: _utils.noop,\n  onDragStop: _utils.noop,\n  onResizeStart: _utils.noop,\n  onResize: _utils.noop,\n  onResizeStop: _utils.noop,\n  onDrop: _utils.noop,\n  onDropDragOver: _utils.noop\n});","map":{"version":3,"sources":["/Users/viviengeschwind/Projects/Website/website-professional/node_modules/react-grid-layout/build/ReactGridLayout.js"],"names":["Object","defineProperty","exports","value","default","React","_interopRequireWildcard","require","_fastEquals","_clsx","_interopRequireDefault","_utils","_calculateUtils","_GridItem","_ReactGridLayoutPropTypes","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","_toPropertyKey","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","TypeError","Number","layoutClassName","isFirefox","test","navigator","userAgent","e","ReactGridLayout","Component","constructor","arguments","activeDrag","layout","synchronizeLayoutWithChildren","props","children","cols","compactType","allowOverlap","mounted","oldDragItem","oldLayout","oldResizeItem","resizing","droppingDOMNode","i","x","y","_ref","node","state","l","getLayoutItem","setState","cloneLayoutItem","onDragStart","_ref2","preventCollision","placeholder","w","h","isUserAction","moveElement","onDrag","compact","_ref3","newLayout","onDragStop","onLayoutMaybeChanged","_ref4","onResizeStart","_ref5","size","handle","shouldMoveItem","finalLayout","withLayoutItem","hasCollisions","indexOf","collisions","getAllCollisions","filter","layoutItem","length","static","onResize","_ref6","onResizeStop","_e$nativeEvent$target","preventDefault","stopPropagation","nativeEvent","target","classList","contains","droppingItem","onDropDragOver","margin","rowHeight","maxRows","width","containerPadding","transformScale","onDragOverResult","removeDroppingPlaceholder","finalDroppingItem","layerX","layerY","droppingPosition","left","top","positionParams","containerWidth","calculatedPosition","calcXY","createElement","isDraggable","shouldUpdatePosition","dragEnterCounter","item","find","onDrop","componentDidMount","getDerivedStateFromProps","nextProps","prevState","newLayoutBase","deepEqual","propsLayout","childrenEqual","shouldComponentUpdate","nextState","fastRGLPropsEqual","componentDidUpdate","prevProps","containerHeight","autoSize","nbRow","bottom","containerPaddingY","onLayoutChange","useCSSTransforms","className","concat","isResizable","isBounded","processGridItem","child","isDroppingItem","draggableCancel","draggableHandle","resizeHandles","resizeHandle","draggable","resizable","resizeHandlesOptions","bounded","cancel","usePercentages","minH","minW","maxH","maxW","render","style","isDroppable","innerRef","mergedClassName","mergedStyle","height","ref","noop","onDragLeave","onDragEnter","onDragOver","Children","map","Infinity","verticalCompact"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _fastEquals = require(\"fast-equals\");\nvar _clsx = _interopRequireDefault(require(\"clsx\"));\nvar _utils = require(\"./utils\");\nvar _calculateUtils = require(\"./calculateUtils\");\nvar _GridItem = _interopRequireDefault(require(\"./GridItem\"));\nvar _ReactGridLayoutPropTypes = _interopRequireDefault(require(\"./ReactGridLayoutPropTypes\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  CompactType,\n  GridResizeEvent,\n  GridDragEvent,\n  DragOverEvent,\n  Layout,\n  DroppingPosition,\n  LayoutItem\n} from \"./utils\";*/\n// Types\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: type State = {\n  activeDrag: ?LayoutItem,\n  layout: Layout,\n  mounted: boolean,\n  oldDragItem: ?LayoutItem,\n  oldLayout: ?Layout,\n  oldResizeItem: ?LayoutItem,\n  resizing: boolean,\n  droppingDOMNode: ?ReactElement<any>,\n  droppingPosition?: DroppingPosition,\n  // Mirrored props\n  children: ReactChildrenArray<ReactElement<any>>,\n  compactType?: CompactType,\n  propsLayout?: Layout\n};*/\n/*:: import type { Props, DefaultProps } from \"./ReactGridLayoutPropTypes\";*/\n// End Types\nconst layoutClassName = \"react-grid-layout\";\nlet isFirefox = false;\n// Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch (e) {\n  /* Ignore */\n}\n\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\nclass ReactGridLayout extends React.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      activeDrag: null,\n      layout: (0, _utils.synchronizeLayoutWithChildren)(this.props.layout, this.props.children, this.props.cols,\n      // Legacy support for verticalCompact: false\n      (0, _utils.compactType)(this.props), this.props.allowOverlap),\n      mounted: false,\n      oldDragItem: null,\n      oldLayout: null,\n      oldResizeItem: null,\n      resizing: false,\n      droppingDOMNode: null,\n      children: []\n    });\n    _defineProperty(this, \"dragEnterCounter\", 0);\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStart\", (i /*: string*/, x /*: number*/, y /*: number*/, _ref /*:: */) => {\n      let {\n        e,\n        node\n      } /*: GridDragEvent*/ = _ref /*: GridDragEvent*/;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldDragItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: layout\n      });\n      return this.props.onDragStart(layout, l, l, null, e, node);\n    });\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDrag\", (i, x, y, _ref2) => {\n      let {\n        e,\n        node\n      } = _ref2;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        allowOverlap,\n        preventCollision\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n\n      // Move the element to the dragged location.\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n      this.setState({\n        layout: allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStop\", (i, x, y, _ref3) => {\n      let {\n        e,\n        node\n      } = _ref3;\n      if (!this.state.activeDrag) return;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Move the element here\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onDragStop(newLayout, oldDragItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldDragItem: null,\n        oldLayout: null\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    _defineProperty(this, \"onResizeStart\", (i, w, h, _ref4) => {\n      let {\n        e,\n        node\n      } = _ref4;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldResizeItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: this.state.layout,\n        resizing: true\n      });\n      this.props.onResizeStart(layout, l, l, null, e, node);\n    });\n    _defineProperty(this, \"onResize\", (i, w, h, _ref5) => {\n      let {\n        e,\n        node,\n        size,\n        handle\n      } = _ref5;\n      const {\n        oldResizeItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      let shouldMoveItem = false;\n      let finalLayout;\n      let x;\n      let y;\n      const [newLayout, l] = (0, _utils.withLayoutItem)(layout, i, l => {\n        let hasCollisions;\n        x = l.x;\n        y = l.y;\n        if ([\"sw\", \"w\", \"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n          if ([\"sw\", \"nw\", \"w\"].indexOf(handle) !== -1) {\n            x = l.x + (l.w - w);\n            w = l.x !== x && x < 0 ? l.w : w;\n            x = x < 0 ? 0 : x;\n          }\n          if ([\"ne\", \"n\", \"nw\"].indexOf(handle) !== -1) {\n            y = l.y + (l.h - h);\n            h = l.y !== y && y < 0 ? l.h : h;\n            y = y < 0 ? 0 : y;\n          }\n          shouldMoveItem = true;\n        }\n\n        // Something like quad tree should be used\n        // to find collisions faster\n        if (preventCollision && !allowOverlap) {\n          const collisions = (0, _utils.getAllCollisions)(layout, {\n            ...l,\n            w,\n            h,\n            x,\n            y\n          }).filter(layoutItem => layoutItem.i !== l.i);\n          hasCollisions = collisions.length > 0;\n\n          // If we're colliding, we need adjust the placeholder.\n          if (hasCollisions) {\n            // Reset layoutItem dimensions if there were collisions\n            y = l.y;\n            h = l.h;\n            x = l.x;\n            w = l.w;\n            shouldMoveItem = false;\n          }\n        }\n        l.w = w;\n        l.h = h;\n        return l;\n      });\n\n      // Shouldn't ever happen, but typechecking makes it necessary\n      if (!l) return;\n      finalLayout = newLayout;\n      if (shouldMoveItem) {\n        // Move the element to the new position.\n        const isUserAction = true;\n        finalLayout = (0, _utils.moveElement)(newLayout, l, x, y, isUserAction, this.props.preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      }\n\n      // Create placeholder element (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        static: true,\n        i: i\n      };\n      this.props.onResize(finalLayout, oldResizeItem, l, placeholder, e, node);\n\n      // Re-compact the newLayout and set the drag placeholder.\n      this.setState({\n        layout: allowOverlap ? finalLayout : (0, _utils.compact)(finalLayout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    _defineProperty(this, \"onResizeStop\", (i, w, h, _ref6) => {\n      let {\n        e,\n        node\n      } = _ref6;\n      const {\n        layout,\n        oldResizeItem\n      } = this.state;\n      const {\n        cols,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onResizeStop(newLayout, oldResizeItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldResizeItem: null,\n        oldLayout: null,\n        resizing: false\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    // Called while dragging an element. Part of browser native drag/drop API.\n    // Native event target might be the layout itself, or an element within the layout.\n    _defineProperty(this, \"onDragOver\", e => {\n      var _e$nativeEvent$target;\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n\n      // we should ignore events from layout's children in Firefox\n      // to avoid unpredictable jumping of a dropping placeholder\n      // FIXME remove this hack\n      if (isFirefox &&\n      // $FlowIgnore can't figure this out\n      !((_e$nativeEvent$target = e.nativeEvent.target) !== null && _e$nativeEvent$target !== void 0 && _e$nativeEvent$target.classList.contains(layoutClassName))) {\n        return false;\n      }\n      const {\n        droppingItem,\n        onDropDragOver,\n        margin,\n        cols,\n        rowHeight,\n        maxRows,\n        width,\n        containerPadding,\n        transformScale\n      } = this.props;\n      // Allow user to customize the dropping item or short-circuit the drop based on the results\n      // of the `onDragOver(e: Event)` callback.\n      const onDragOverResult = onDropDragOver === null || onDropDragOver === void 0 ? void 0 : onDropDragOver(e);\n      if (onDragOverResult === false) {\n        if (this.state.droppingDOMNode) {\n          this.removeDroppingPlaceholder();\n        }\n        return false;\n      }\n      const finalDroppingItem = {\n        ...droppingItem,\n        ...onDragOverResult\n      };\n      const {\n        layout\n      } = this.state;\n      // This is relative to the DOM element that this event fired for.\n      const {\n        layerX,\n        layerY\n      } = e.nativeEvent;\n      const droppingPosition = {\n        left: layerX / transformScale,\n        top: layerY / transformScale,\n        e\n      };\n      if (!this.state.droppingDOMNode) {\n        const positionParams /*: PositionParams*/ = {\n          cols,\n          margin,\n          maxRows,\n          rowHeight,\n          containerWidth: width,\n          containerPadding: containerPadding || margin\n        };\n        const calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);\n        this.setState({\n          droppingDOMNode: /*#__PURE__*/React.createElement(\"div\", {\n            key: finalDroppingItem.i\n          }),\n          droppingPosition,\n          layout: [...layout, {\n            ...finalDroppingItem,\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            static: false,\n            isDraggable: true\n          }]\n        });\n      } else if (this.state.droppingPosition) {\n        const {\n          left,\n          top\n        } = this.state.droppingPosition;\n        const shouldUpdatePosition = left != layerX || top != layerY;\n        if (shouldUpdatePosition) {\n          this.setState({\n            droppingPosition\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"removeDroppingPlaceholder\", () => {\n      const {\n        droppingItem,\n        cols\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const newLayout = (0, _utils.compact)(layout.filter(l => l.i !== droppingItem.i), (0, _utils.compactType)(this.props), cols, this.props.allowOverlap);\n      this.setState({\n        layout: newLayout,\n        droppingDOMNode: null,\n        activeDrag: null,\n        droppingPosition: undefined\n      });\n    });\n    _defineProperty(this, \"onDragLeave\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter--;\n\n      // onDragLeave can be triggered on each layout's child.\n      // But we know that count of dragEnter and dragLeave events\n      // will be balanced after leaving the layout's container\n      // so we can increase and decrease count of dragEnter and\n      // when it'll be equal to 0 we'll remove the placeholder\n      if (this.dragEnterCounter === 0) {\n        this.removeDroppingPlaceholder();\n      }\n    });\n    _defineProperty(this, \"onDragEnter\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter++;\n    });\n    _defineProperty(this, \"onDrop\", (e /*: Event*/) => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      const {\n        droppingItem\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const item = layout.find(l => l.i === droppingItem.i);\n\n      // reset dragEnter counter on drop\n      this.dragEnterCounter = 0;\n      this.removeDroppingPlaceholder();\n      this.props.onDrop(layout, item, e);\n    });\n  }\n  componentDidMount() {\n    this.setState({\n      mounted: true\n    });\n    // Possibly call back with layout on mount. This should be done after correcting the layout width\n    // to ensure we don't rerender with the wrong width.\n    this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n  }\n  static getDerivedStateFromProps(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State> | null*/{\n    let newLayoutBase;\n    if (prevState.activeDrag) {\n      return null;\n    }\n\n    // Legacy support for compactType\n    // Allow parent to set layout directly.\n    if (!(0, _fastEquals.deepEqual)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {\n      newLayoutBase = nextProps.layout;\n    } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {\n      // If children change, also regenerate the layout. Use our state\n      // as the base in case because it may be more up to date than\n      // what is in props.\n      newLayoutBase = prevState.layout;\n    }\n\n    // We need to regenerate the layout.\n    if (newLayoutBase) {\n      const newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);\n      return {\n        layout: newLayout,\n        // We need to save these props to state for using\n        // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n        compactType: nextProps.compactType,\n        children: nextProps.children,\n        propsLayout: nextProps.layout\n      };\n    }\n    return null;\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    return (\n      // NOTE: this is almost always unequal. Therefore the only way to get better performance\n      // from SCU is if the user intentionally memoizes children. If they do, and they can\n      // handle changes properly, performance will increase.\n      this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _fastEquals.deepEqual) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition\n    );\n  }\n  componentDidUpdate(prevProps /*: Props*/, prevState /*: State*/) {\n    if (!this.state.activeDrag) {\n      const newLayout = this.state.layout;\n      const oldLayout = prevState.layout;\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n  }\n\n  /**\n   * Calculates a pixel value for the container.\n   * @return {String} Container height in pixels.\n   */\n  containerHeight() /*: ?string*/{\n    if (!this.props.autoSize) return;\n    const nbRow = (0, _utils.bottom)(this.state.layout);\n    const containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];\n    return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + \"px\";\n  }\n  onLayoutMaybeChanged(newLayout /*: Layout*/, oldLayout /*: ?Layout*/) {\n    if (!oldLayout) oldLayout = this.state.layout;\n    if (!(0, _fastEquals.deepEqual)(oldLayout, newLayout)) {\n      this.props.onLayoutChange(newLayout);\n    }\n  }\n  /**\n   * Create a placeholder object.\n   * @return {Element} Placeholder div.\n   */\n  placeholder() /*: ?ReactElement<any>*/{\n    const {\n      activeDrag\n    } = this.state;\n    if (!activeDrag) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      useCSSTransforms,\n      transformScale\n    } = this.props;\n\n    // {...this.state.activeDrag} is pretty slow, actually\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      w: activeDrag.w,\n      h: activeDrag.h,\n      x: activeDrag.x,\n      y: activeDrag.y,\n      i: activeDrag.i,\n      className: \"react-grid-placeholder \".concat(this.state.resizing ? \"placeholder-resizing\" : \"\"),\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      isDraggable: false,\n      isResizable: false,\n      isBounded: false,\n      useCSSTransforms: useCSSTransforms,\n      transformScale: transformScale\n    }, /*#__PURE__*/React.createElement(\"div\", null));\n  }\n\n  /**\n   * Given a grid item, set its style attributes & surround in a <Draggable>.\n   * @param  {Element} child React element.\n   * @return {Element}       Element wrapped in draggable and properly placed.\n   */\n  processGridItem(child /*: ReactElement<any>*/, isDroppingItem /*: boolean*/) /*: ?ReactElement<any>*/{\n    if (!child || !child.key) return;\n    const l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));\n    if (!l) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      isDraggable,\n      isResizable,\n      isBounded,\n      useCSSTransforms,\n      transformScale,\n      draggableCancel,\n      draggableHandle,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const {\n      mounted,\n      droppingPosition\n    } = this.state;\n\n    // Determine user manipulations possible.\n    // If an item is static, it can't be manipulated by default.\n    // Any properties defined directly on the grid item will take precedence.\n    const draggable = typeof l.isDraggable === \"boolean\" ? l.isDraggable : !l.static && isDraggable;\n    const resizable = typeof l.isResizable === \"boolean\" ? l.isResizable : !l.static && isResizable;\n    const resizeHandlesOptions = l.resizeHandles || resizeHandles;\n\n    // isBounded set on child if set on parent, and child is not explicitly false\n    const bounded = draggable && isBounded && l.isBounded !== false;\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      cancel: draggableCancel,\n      handle: draggableHandle,\n      onDragStop: this.onDragStop,\n      onDragStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onResizeStart: this.onResizeStart,\n      onResize: this.onResize,\n      onResizeStop: this.onResizeStop,\n      isDraggable: draggable,\n      isResizable: resizable,\n      isBounded: bounded,\n      useCSSTransforms: useCSSTransforms && mounted,\n      usePercentages: !mounted,\n      transformScale: transformScale,\n      w: l.w,\n      h: l.h,\n      x: l.x,\n      y: l.y,\n      i: l.i,\n      minH: l.minH,\n      minW: l.minW,\n      maxH: l.maxH,\n      maxW: l.maxW,\n      static: l.static,\n      droppingPosition: isDroppingItem ? droppingPosition : undefined,\n      resizeHandles: resizeHandlesOptions,\n      resizeHandle: resizeHandle\n    }, child);\n  }\n  render() /*: React.Element<\"div\">*/{\n    const {\n      className,\n      style,\n      isDroppable,\n      innerRef\n    } = this.props;\n    const mergedClassName = (0, _clsx.default)(layoutClassName, className);\n    const mergedStyle = {\n      height: this.containerHeight(),\n      ...style\n    };\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: innerRef,\n      className: mergedClassName,\n      style: mergedStyle,\n      onDrop: isDroppable ? this.onDrop : _utils.noop,\n      onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,\n      onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,\n      onDragOver: isDroppable ? this.onDragOver : _utils.noop\n    }, React.Children.map(this.props.children, child => this.processGridItem(child)), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());\n  }\n}\nexports.default = ReactGridLayout;\n// TODO publish internal ReactClass displayName transform\n_defineProperty(ReactGridLayout, \"displayName\", \"ReactGridLayout\");\n// Refactored to another module to make way for preval\n_defineProperty(ReactGridLayout, \"propTypes\", _ReactGridLayoutPropTypes.default);\n_defineProperty(ReactGridLayout, \"defaultProps\", {\n  autoSize: true,\n  cols: 12,\n  className: \"\",\n  style: {},\n  draggableHandle: \"\",\n  draggableCancel: \"\",\n  containerPadding: null,\n  rowHeight: 150,\n  maxRows: Infinity,\n  // infinite vertical growth\n  layout: [],\n  margin: [10, 10],\n  isBounded: false,\n  isDraggable: true,\n  isResizable: true,\n  allowOverlap: false,\n  isDroppable: false,\n  useCSSTransforms: true,\n  transformScale: 1,\n  verticalCompact: true,\n  compactType: \"vertical\",\n  preventCollision: false,\n  droppingItem: {\n    i: \"__dropping-elem__\",\n    h: 1,\n    w: 1\n  },\n  resizeHandles: [\"se\"],\n  onLayoutChange: _utils.noop,\n  onDragStart: _utils.noop,\n  onDrag: _utils.noop,\n  onDragStop: _utils.noop,\n  onResizeStart: _utils.noop,\n  onResize: _utils.noop,\n  onResizeStop: _utils.noop,\n  onDrop: _utils.noop,\n  onDropDragOver: _utils.noop\n});"]},"metadata":{},"sourceType":"script"}