{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\n\nvar _domFns = require(\"./utils/domFns\");\n\nvar _positionFns = require(\"./utils/positionFns\");\n\nvar _shims = require(\"./utils/shims\");\n\nvar _log = _interopRequireDefault(require(\"./utils/log\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/\n\n/*:: import type {Element as ReactElement} from 'react';*/\n// Simple abstraction for dragging events names.\n\n\nconst eventsFor = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n}; // Default to mouse events.\n\nlet dragEventFor = eventsFor.mouse;\n/*:: export type DraggableData = {\n  node: HTMLElement,\n  x: number, y: number,\n  deltaX: number, deltaY: number,\n  lastX: number, lastY: number,\n};*/\n\n/*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/\n\n/*:: export type ControlPosition = {x: number, y: number};*/\n\n/*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/\n\n/*:: export type DraggableCoreDefaultProps = {\n  allowAnyClick: boolean,\n  disabled: boolean,\n  enableUserSelectHack: boolean,\n  onStart: DraggableEventHandler,\n  onDrag: DraggableEventHandler,\n  onStop: DraggableEventHandler,\n  onMouseDown: (e: MouseEvent) => void,\n  scale: number,\n};*/\n\n/*:: export type DraggableCoreProps = {\n  ...DraggableCoreDefaultProps,\n  cancel: string,\n  children: ReactElement<any>,\n  offsetParent: HTMLElement,\n  grid: [number, number],\n  handle: string,\n  nodeRef?: ?React.ElementRef<any>,\n};*/\n//\n// Define <DraggableCore>.\n//\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n// work well with libraries that require more control over the element.\n//\n\nclass DraggableCore extends React.Component\n/*:: <DraggableCoreProps>*/\n{\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"dragging\", false); // Used while dragging to determine deltas.\n\n\n    _defineProperty(this, \"lastX\", NaN);\n\n    _defineProperty(this, \"lastY\", NaN);\n\n    _defineProperty(this, \"touchIdentifier\", null);\n\n    _defineProperty(this, \"mounted\", false);\n\n    _defineProperty(this, \"handleDragStart\", e => {\n      // Make it possible to attach event handlers on top of this one.\n      this.props.onMouseDown(e); // Only accept left-clicks.\n\n      if (!this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false; // Get nodes. Be sure to grab relative document (could be iframed)\n\n      const thisNode = this.findDOMNode();\n\n      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n        throw new Error('<DraggableCore> not mounted on DragStart!');\n      }\n\n      const {\n        ownerDocument\n      } = thisNode; // Short circuit if handle or cancel prop was provided and selector doesn't match.\n\n      if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {\n        return;\n      } // Prevent scrolling on mobile devices, like ipad/iphone.\n      // Important that this is after handle/cancel.\n\n\n      if (e.type === 'touchstart') e.preventDefault(); // Set touch identifier in component state if this is a touch event. This allows us to\n      // distinguish between individual touches on multitouch screens by identifying which\n      // touchpoint was set to this element.\n\n      const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);\n      this.touchIdentifier = touchIdentifier; // Get the current drag point from the event. This is used as the offset.\n\n      const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);\n      if (position == null) return; // not possible but satisfies flow\n\n      const {\n        x,\n        y\n      } = position; // Create an event object with all the data parents need to make a decision here.\n\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n      (0, _log.default)('DraggableCore: handleDragStart: %j', coreEvent); // Call event handler. If it returns explicit false, cancel.\n\n      (0, _log.default)('calling', this.props.onStart);\n      const shouldUpdate = this.props.onStart(e, coreEvent);\n      if (shouldUpdate === false || this.mounted === false) return; // Add a style to the body to disable user-select. This prevents text from\n      // being selected all over the page.\n\n      if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument); // Initiate dragging. Set the current x and y as offsets\n      // so we know how much we've moved during the drag. This allows us\n      // to drag elements around even if they have been moved, without issue.\n\n      this.dragging = true;\n      this.lastX = x;\n      this.lastY = y; // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n      // this element. We use different events depending on whether or not we have detected that this\n      // is a touch-capable device.\n\n      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);\n      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);\n    });\n\n    _defineProperty(this, \"handleDrag\", e => {\n      // Get the current drag point from the event. This is used as the offset.\n      const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n      if (position == null) return;\n      let {\n        x,\n        y\n      } = position; // Snap to grid if prop has been provided\n\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.lastX,\n            deltaY = y - this.lastY;\n        [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n        if (!deltaX && !deltaY) return; // skip useless drag\n\n        x = this.lastX + deltaX, y = this.lastY + deltaY;\n      }\n\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n      (0, _log.default)('DraggableCore: handleDrag: %j', coreEvent); // Call event handler. If it returns explicit false, trigger end.\n\n      const shouldUpdate = this.props.onDrag(e, coreEvent);\n\n      if (shouldUpdate === false || this.mounted === false) {\n        try {\n          // $FlowIgnore\n          this.handleDragStop(new MouseEvent('mouseup'));\n        } catch (err) {\n          // Old browsers\n          const event = document.createEvent('MouseEvents')\n          /*: any*/\n          ; // I see why this insanity was deprecated\n          // $FlowIgnore\n\n          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n          this.handleDragStop(event);\n        }\n\n        return;\n      }\n\n      this.lastX = x;\n      this.lastY = y;\n    });\n\n    _defineProperty(this, \"handleDragStop\", e => {\n      if (!this.dragging) return;\n      const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n      if (position == null) return;\n      let {\n        x,\n        y\n      } = position; // Snap to grid if prop has been provided\n\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.lastX || 0;\n        let deltaY = y - this.lastY || 0;\n        [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n        x = this.lastX + deltaX, y = this.lastY + deltaY;\n      }\n\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y); // Call event handler\n\n      const shouldContinue = this.props.onStop(e, coreEvent);\n      if (shouldContinue === false || this.mounted === false) return false;\n      const thisNode = this.findDOMNode();\n\n      if (thisNode) {\n        // Remove user-select hack\n        if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);\n      }\n\n      (0, _log.default)('DraggableCore: handleDragStop: %j', coreEvent); // Reset the el.\n\n      this.dragging = false;\n      this.lastX = NaN;\n      this.lastY = NaN;\n\n      if (thisNode) {\n        // Remove event handlers\n        (0, _log.default)('DraggableCore: Removing handlers');\n        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n      }\n    });\n\n    _defineProperty(this, \"onMouseDown\", e => {\n      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n\n      return this.handleDragStart(e);\n    });\n\n    _defineProperty(this, \"onMouseUp\", e => {\n      dragEventFor = eventsFor.mouse;\n      return this.handleDragStop(e);\n    }); // Same as onMouseDown (start drag), but now consider this a touch device.\n\n\n    _defineProperty(this, \"onTouchStart\", e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStart(e);\n    });\n\n    _defineProperty(this, \"onTouchEnd\", e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStop(e);\n    });\n  }\n\n  componentDidMount() {\n    this.mounted = true; // Touch handlers must be added with {passive: false} to be cancelable.\n    // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n\n    const thisNode = this.findDOMNode();\n\n    if (thisNode) {\n      (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.mounted = false; // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n    // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n\n    const thisNode = this.findDOMNode();\n\n    if (thisNode) {\n      const {\n        ownerDocument\n      } = thisNode;\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n      (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n        passive: false\n      });\n      if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);\n    }\n  } // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n  // the underlying DOM node ourselves. See the README for more information.\n\n\n  findDOMNode()\n  /*: ?HTMLElement*/\n  {\n    var _this$props, _this$props2;\n\n    return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);\n  }\n\n  render()\n  /*: React.Element<any>*/\n  {\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    return /*#__PURE__*/React.cloneElement(React.Children.only(this.props.children), {\n      // Note: mouseMove handler is attached to document so it will still function\n      // when the user drags quickly and leaves the bounds of the element.\n      onMouseDown: this.onMouseDown,\n      onMouseUp: this.onMouseUp,\n      // onTouchStart is added on `componentDidMount` so they can be added with\n      // {passive: false}, which allows it to cancel. See\n      // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n      onTouchEnd: this.onTouchEnd\n    });\n  }\n\n}\n\nexports.default = DraggableCore;\n\n_defineProperty(DraggableCore, \"displayName\", 'DraggableCore');\n\n_defineProperty(DraggableCore, \"propTypes\", {\n  /**\n   * `allowAnyClick` allows dragging using any mouse button.\n   * By default, we only accept the left button.\n   *\n   * Defaults to `false`.\n   */\n  allowAnyClick: _propTypes.default.bool,\n  children: _propTypes.default.node.isRequired,\n\n  /**\n   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n   * with the exception of `onMouseDown`, will not fire.\n   */\n  disabled: _propTypes.default.bool,\n\n  /**\n   * By default, we add 'user-select:none' attributes to the document body\n   * to prevent ugly text selection during drag. If this is causing problems\n   * for your app, set this to `false`.\n   */\n  enableUserSelectHack: _propTypes.default.bool,\n\n  /**\n   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\n   * instead of using the parent node.\n   */\n  offsetParent: function (props\n  /*: DraggableCoreProps*/\n  , propName\n  /*: $Keys<DraggableCoreProps>*/\n  ) {\n    if (props[propName] && props[propName].nodeType !== 1) {\n      throw new Error('Draggable\\'s offsetParent must be a DOM Node.');\n    }\n  },\n\n  /**\n   * `grid` specifies the x and y that dragging should snap to.\n   */\n  grid: _propTypes.default.arrayOf(_propTypes.default.number),\n\n  /**\n   * `handle` specifies a selector to be used as the handle that initiates drag.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable handle=\".handle\">\n   *              <div>\n   *                  <div className=\"handle\">Click me to drag</div>\n   *                  <div>This is some other content</div>\n   *              </div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */\n  handle: _propTypes.default.string,\n\n  /**\n   * `cancel` specifies a selector to be used to prevent drag initialization.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *           return(\n   *               <Draggable cancel=\".cancel\">\n   *                   <div>\n   *                     <div className=\"cancel\">You can't drag from here</div>\n   *                     <div>Dragging here works fine</div>\n   *                   </div>\n   *               </Draggable>\n   *           );\n   *       }\n   *   });\n   * ```\n   */\n  cancel: _propTypes.default.string,\n\n  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.\n   * Unfortunately, in order for <Draggable> to work properly, we need raw access\n   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`\n   * as in this example:\n   *\n   * function MyComponent() {\n   *   const nodeRef = React.useRef(null);\n   *   return (\n   *     <Draggable nodeRef={nodeRef}>\n   *       <div ref={nodeRef}>Example Target</div>\n   *     </Draggable>\n   *   );\n   * }\n   *\n   * This can be used for arbitrarily nested components, so long as the ref ends up\n   * pointing to the actual child DOM node and not a custom component.\n   */\n  nodeRef: _propTypes.default.object,\n\n  /**\n   * Called when dragging starts.\n   * If this function returns the boolean false, dragging will be canceled.\n   */\n  onStart: _propTypes.default.func,\n\n  /**\n   * Called while dragging.\n   * If this function returns the boolean false, dragging will be canceled.\n   */\n  onDrag: _propTypes.default.func,\n\n  /**\n   * Called when dragging stops.\n   * If this function returns the boolean false, the drag will remain active.\n   */\n  onStop: _propTypes.default.func,\n\n  /**\n   * A workaround option which can be passed if onMouseDown needs to be accessed,\n   * since it'll always be blocked (as there is internal use of onMouseDown)\n   */\n  onMouseDown: _propTypes.default.func,\n\n  /**\n   * `scale`, if set, applies scaling while dragging an element\n   */\n  scale: _propTypes.default.number,\n\n  /**\n   * These properties should be defined on the child, not here.\n   */\n  className: _shims.dontSetMe,\n  style: _shims.dontSetMe,\n  transform: _shims.dontSetMe\n});\n\n_defineProperty(DraggableCore, \"defaultProps\", {\n  allowAnyClick: false,\n  // by default only accept left click\n  disabled: false,\n  enableUserSelectHack: true,\n  onStart: function () {},\n  onDrag: function () {},\n  onStop: function () {},\n  onMouseDown: function () {},\n  scale: 1\n});","map":{"version":3,"sources":["/Users/viviengeschwind/Projects/Website/website-professional/node_modules/react-draggable/build/cjs/DraggableCore.js"],"names":["Object","defineProperty","exports","value","default","React","_interopRequireWildcard","require","_propTypes","_interopRequireDefault","_reactDom","_domFns","_positionFns","_shims","_log","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","_toPropertyKey","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","TypeError","Number","eventsFor","touch","start","move","stop","mouse","dragEventFor","DraggableCore","Component","constructor","arguments","NaN","e","props","onMouseDown","allowAnyClick","button","thisNode","findDOMNode","ownerDocument","body","Error","disabled","target","defaultView","Node","handle","matchesSelectorAndParentsTo","cancel","type","preventDefault","touchIdentifier","getTouchIdentifier","position","getControlPosition","x","y","coreEvent","createCoreData","onStart","shouldUpdate","mounted","enableUserSelectHack","addUserSelectStyles","dragging","lastX","lastY","addEvent","handleDrag","handleDragStop","Array","isArray","grid","deltaX","deltaY","snapToGrid","onDrag","MouseEvent","err","event","document","createEvent","initMouseEvent","window","shouldContinue","onStop","removeUserSelectStyles","removeEvent","handleDragStart","componentDidMount","onTouchStart","passive","componentWillUnmount","_this$props","_this$props2","nodeRef","current","render","cloneElement","Children","only","children","onMouseUp","onTouchEnd","bool","node","isRequired","offsetParent","propName","nodeType","arrayOf","number","string","object","func","scale","className","dontSetMe","style","transform"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\nvar _domFns = require(\"./utils/domFns\");\nvar _positionFns = require(\"./utils/positionFns\");\nvar _shims = require(\"./utils/shims\");\nvar _log = _interopRequireDefault(require(\"./utils/log\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/\n/*:: import type {Element as ReactElement} from 'react';*/\n// Simple abstraction for dragging events names.\nconst eventsFor = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n};\n\n// Default to mouse events.\nlet dragEventFor = eventsFor.mouse;\n/*:: export type DraggableData = {\n  node: HTMLElement,\n  x: number, y: number,\n  deltaX: number, deltaY: number,\n  lastX: number, lastY: number,\n};*/\n/*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/\n/*:: export type ControlPosition = {x: number, y: number};*/\n/*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/\n/*:: export type DraggableCoreDefaultProps = {\n  allowAnyClick: boolean,\n  disabled: boolean,\n  enableUserSelectHack: boolean,\n  onStart: DraggableEventHandler,\n  onDrag: DraggableEventHandler,\n  onStop: DraggableEventHandler,\n  onMouseDown: (e: MouseEvent) => void,\n  scale: number,\n};*/\n/*:: export type DraggableCoreProps = {\n  ...DraggableCoreDefaultProps,\n  cancel: string,\n  children: ReactElement<any>,\n  offsetParent: HTMLElement,\n  grid: [number, number],\n  handle: string,\n  nodeRef?: ?React.ElementRef<any>,\n};*/\n//\n// Define <DraggableCore>.\n//\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n// work well with libraries that require more control over the element.\n//\n\nclass DraggableCore extends React.Component /*:: <DraggableCoreProps>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"dragging\", false);\n    // Used while dragging to determine deltas.\n    _defineProperty(this, \"lastX\", NaN);\n    _defineProperty(this, \"lastY\", NaN);\n    _defineProperty(this, \"touchIdentifier\", null);\n    _defineProperty(this, \"mounted\", false);\n    _defineProperty(this, \"handleDragStart\", e => {\n      // Make it possible to attach event handlers on top of this one.\n      this.props.onMouseDown(e);\n\n      // Only accept left-clicks.\n      if (!this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;\n\n      // Get nodes. Be sure to grab relative document (could be iframed)\n      const thisNode = this.findDOMNode();\n      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n        throw new Error('<DraggableCore> not mounted on DragStart!');\n      }\n      const {\n        ownerDocument\n      } = thisNode;\n\n      // Short circuit if handle or cancel prop was provided and selector doesn't match.\n      if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {\n        return;\n      }\n\n      // Prevent scrolling on mobile devices, like ipad/iphone.\n      // Important that this is after handle/cancel.\n      if (e.type === 'touchstart') e.preventDefault();\n\n      // Set touch identifier in component state if this is a touch event. This allows us to\n      // distinguish between individual touches on multitouch screens by identifying which\n      // touchpoint was set to this element.\n      const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);\n      this.touchIdentifier = touchIdentifier;\n\n      // Get the current drag point from the event. This is used as the offset.\n      const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);\n      if (position == null) return; // not possible but satisfies flow\n      const {\n        x,\n        y\n      } = position;\n\n      // Create an event object with all the data parents need to make a decision here.\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n      (0, _log.default)('DraggableCore: handleDragStart: %j', coreEvent);\n\n      // Call event handler. If it returns explicit false, cancel.\n      (0, _log.default)('calling', this.props.onStart);\n      const shouldUpdate = this.props.onStart(e, coreEvent);\n      if (shouldUpdate === false || this.mounted === false) return;\n\n      // Add a style to the body to disable user-select. This prevents text from\n      // being selected all over the page.\n      if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);\n\n      // Initiate dragging. Set the current x and y as offsets\n      // so we know how much we've moved during the drag. This allows us\n      // to drag elements around even if they have been moved, without issue.\n      this.dragging = true;\n      this.lastX = x;\n      this.lastY = y;\n\n      // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n      // this element. We use different events depending on whether or not we have detected that this\n      // is a touch-capable device.\n      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);\n      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);\n    });\n    _defineProperty(this, \"handleDrag\", e => {\n      // Get the current drag point from the event. This is used as the offset.\n      const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n      if (position == null) return;\n      let {\n        x,\n        y\n      } = position;\n\n      // Snap to grid if prop has been provided\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.lastX,\n          deltaY = y - this.lastY;\n        [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n        if (!deltaX && !deltaY) return; // skip useless drag\n        x = this.lastX + deltaX, y = this.lastY + deltaY;\n      }\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n      (0, _log.default)('DraggableCore: handleDrag: %j', coreEvent);\n\n      // Call event handler. If it returns explicit false, trigger end.\n      const shouldUpdate = this.props.onDrag(e, coreEvent);\n      if (shouldUpdate === false || this.mounted === false) {\n        try {\n          // $FlowIgnore\n          this.handleDragStop(new MouseEvent('mouseup'));\n        } catch (err) {\n          // Old browsers\n          const event = ((document.createEvent('MouseEvents') /*: any*/) /*: MouseTouchEvent*/);\n          // I see why this insanity was deprecated\n          // $FlowIgnore\n          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n          this.handleDragStop(event);\n        }\n        return;\n      }\n      this.lastX = x;\n      this.lastY = y;\n    });\n    _defineProperty(this, \"handleDragStop\", e => {\n      if (!this.dragging) return;\n      const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n      if (position == null) return;\n      let {\n        x,\n        y\n      } = position;\n\n      // Snap to grid if prop has been provided\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.lastX || 0;\n        let deltaY = y - this.lastY || 0;\n        [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n        x = this.lastX + deltaX, y = this.lastY + deltaY;\n      }\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n\n      // Call event handler\n      const shouldContinue = this.props.onStop(e, coreEvent);\n      if (shouldContinue === false || this.mounted === false) return false;\n      const thisNode = this.findDOMNode();\n      if (thisNode) {\n        // Remove user-select hack\n        if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);\n      }\n      (0, _log.default)('DraggableCore: handleDragStop: %j', coreEvent);\n\n      // Reset the el.\n      this.dragging = false;\n      this.lastX = NaN;\n      this.lastY = NaN;\n      if (thisNode) {\n        // Remove event handlers\n        (0, _log.default)('DraggableCore: Removing handlers');\n        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n      }\n    });\n    _defineProperty(this, \"onMouseDown\", e => {\n      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n\n      return this.handleDragStart(e);\n    });\n    _defineProperty(this, \"onMouseUp\", e => {\n      dragEventFor = eventsFor.mouse;\n      return this.handleDragStop(e);\n    });\n    // Same as onMouseDown (start drag), but now consider this a touch device.\n    _defineProperty(this, \"onTouchStart\", e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStart(e);\n    });\n    _defineProperty(this, \"onTouchEnd\", e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStop(e);\n    });\n  }\n  componentDidMount() {\n    this.mounted = true;\n    // Touch handlers must be added with {passive: false} to be cancelable.\n    // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n    const thisNode = this.findDOMNode();\n    if (thisNode) {\n      (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n  componentWillUnmount() {\n    this.mounted = false;\n    // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n    // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n    const thisNode = this.findDOMNode();\n    if (thisNode) {\n      const {\n        ownerDocument\n      } = thisNode;\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n      (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n        passive: false\n      });\n      if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);\n    }\n  }\n\n  // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n  // the underlying DOM node ourselves. See the README for more information.\n  findDOMNode() /*: ?HTMLElement*/{\n    var _this$props, _this$props2;\n    return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);\n  }\n  render() /*: React.Element<any>*/{\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    return /*#__PURE__*/React.cloneElement(React.Children.only(this.props.children), {\n      // Note: mouseMove handler is attached to document so it will still function\n      // when the user drags quickly and leaves the bounds of the element.\n      onMouseDown: this.onMouseDown,\n      onMouseUp: this.onMouseUp,\n      // onTouchStart is added on `componentDidMount` so they can be added with\n      // {passive: false}, which allows it to cancel. See\n      // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n      onTouchEnd: this.onTouchEnd\n    });\n  }\n}\nexports.default = DraggableCore;\n_defineProperty(DraggableCore, \"displayName\", 'DraggableCore');\n_defineProperty(DraggableCore, \"propTypes\", {\n  /**\n   * `allowAnyClick` allows dragging using any mouse button.\n   * By default, we only accept the left button.\n   *\n   * Defaults to `false`.\n   */\n  allowAnyClick: _propTypes.default.bool,\n  children: _propTypes.default.node.isRequired,\n  /**\n   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n   * with the exception of `onMouseDown`, will not fire.\n   */\n  disabled: _propTypes.default.bool,\n  /**\n   * By default, we add 'user-select:none' attributes to the document body\n   * to prevent ugly text selection during drag. If this is causing problems\n   * for your app, set this to `false`.\n   */\n  enableUserSelectHack: _propTypes.default.bool,\n  /**\n   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\n   * instead of using the parent node.\n   */\n  offsetParent: function (props /*: DraggableCoreProps*/, propName /*: $Keys<DraggableCoreProps>*/) {\n    if (props[propName] && props[propName].nodeType !== 1) {\n      throw new Error('Draggable\\'s offsetParent must be a DOM Node.');\n    }\n  },\n  /**\n   * `grid` specifies the x and y that dragging should snap to.\n   */\n  grid: _propTypes.default.arrayOf(_propTypes.default.number),\n  /**\n   * `handle` specifies a selector to be used as the handle that initiates drag.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable handle=\".handle\">\n   *              <div>\n   *                  <div className=\"handle\">Click me to drag</div>\n   *                  <div>This is some other content</div>\n   *              </div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */\n  handle: _propTypes.default.string,\n  /**\n   * `cancel` specifies a selector to be used to prevent drag initialization.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *           return(\n   *               <Draggable cancel=\".cancel\">\n   *                   <div>\n   *                     <div className=\"cancel\">You can't drag from here</div>\n   *                     <div>Dragging here works fine</div>\n   *                   </div>\n   *               </Draggable>\n   *           );\n   *       }\n   *   });\n   * ```\n   */\n  cancel: _propTypes.default.string,\n  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.\n   * Unfortunately, in order for <Draggable> to work properly, we need raw access\n   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`\n   * as in this example:\n   *\n   * function MyComponent() {\n   *   const nodeRef = React.useRef(null);\n   *   return (\n   *     <Draggable nodeRef={nodeRef}>\n   *       <div ref={nodeRef}>Example Target</div>\n   *     </Draggable>\n   *   );\n   * }\n   *\n   * This can be used for arbitrarily nested components, so long as the ref ends up\n   * pointing to the actual child DOM node and not a custom component.\n   */\n  nodeRef: _propTypes.default.object,\n  /**\n   * Called when dragging starts.\n   * If this function returns the boolean false, dragging will be canceled.\n   */\n  onStart: _propTypes.default.func,\n  /**\n   * Called while dragging.\n   * If this function returns the boolean false, dragging will be canceled.\n   */\n  onDrag: _propTypes.default.func,\n  /**\n   * Called when dragging stops.\n   * If this function returns the boolean false, the drag will remain active.\n   */\n  onStop: _propTypes.default.func,\n  /**\n   * A workaround option which can be passed if onMouseDown needs to be accessed,\n   * since it'll always be blocked (as there is internal use of onMouseDown)\n   */\n  onMouseDown: _propTypes.default.func,\n  /**\n   * `scale`, if set, applies scaling while dragging an element\n   */\n  scale: _propTypes.default.number,\n  /**\n   * These properties should be defined on the child, not here.\n   */\n  className: _shims.dontSetMe,\n  style: _shims.dontSetMe,\n  transform: _shims.dontSetMe\n});\n_defineProperty(DraggableCore, \"defaultProps\", {\n  allowAnyClick: false,\n  // by default only accept left click\n  disabled: false,\n  enableUserSelectHack: true,\n  onStart: function () {},\n  onDrag: function () {},\n  onStop: function () {},\n  onMouseDown: function () {},\n  scale: 1\n});"]},"metadata":{},"sourceType":"script"}