{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.resizeItemInDirection = resizeItemInDirection;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\n\nvar _fastEquals = require(\"fast-equals\");\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n\n/*:: export type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";*/\n\n/*:: export type LayoutItem = {\n  w: number,\n  h: number,\n  x: number,\n  y: number,\n  i: string,\n  minW?: number,\n  minH?: number,\n  maxW?: number,\n  maxH?: number,\n  moved?: boolean,\n  static?: boolean,\n  isDraggable?: ?boolean,\n  isResizable?: ?boolean,\n  resizeHandles?: Array<ResizeHandleAxis>,\n  isBounded?: ?boolean\n};*/\n\n/*:: export type Layout = $ReadOnlyArray<LayoutItem>;*/\n\n/*:: export type Position = {\n  left: number,\n  top: number,\n  width: number,\n  height: number\n};*/\n\n/*:: export type ReactDraggableCallbackData = {\n  node: HTMLElement,\n  x?: number,\n  y?: number,\n  deltaX: number,\n  deltaY: number,\n  lastX?: number,\n  lastY?: number\n};*/\n\n/*:: export type PartialPosition = { left: number, top: number };*/\n\n/*:: export type DroppingPosition = { left: number, top: number, e: Event };*/\n\n/*:: export type Size = { width: number, height: number };*/\n\n/*:: export type GridDragEvent = {\n  e: Event,\n  node: HTMLElement,\n  newPosition: PartialPosition\n};*/\n\n/*:: export type GridResizeEvent = {\n  e: Event,\n  node: HTMLElement,\n  size: Size,\n  handle: string\n};*/\n\n/*:: export type DragOverEvent = MouseEvent & {\n  nativeEvent: {\n    layerX: number,\n    layerY: number,\n    ...Event\n  }\n};*/\n\n/*:: export type Pick<FromType, Properties: { [string]: 0 }> = $Exact<\n  $ObjMapi<Properties, <K, V>(k: K, v: V) => $ElementType<FromType, K>>\n>;*/\n// Helpful port from TS\n\n/*:: type REl = ReactElement<any>;*/\n\n/*:: export type ReactChildren = ReactChildrenArray<REl>;*/\n\n/*:: export type EventCallback = (\n  Layout,\n  oldItem: ?LayoutItem,\n  newItem: ?LayoutItem,\n  placeholder: ?LayoutItem,\n  Event,\n  ?HTMLElement\n) => void;*/\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\n\n/*:: export type CompactType = ?(\"horizontal\" | \"vertical\");*/\n\n\nconst isProduction = process.env.NODE_ENV === \"production\";\nconst DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  let max = 0,\n      bottomY;\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  const newLayout = Array(layout.length);\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\n\n\nfunction modifyLayout(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Layout*/\n{\n  const newLayout = Array(layout.length);\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n\n  return newLayout;\n} // Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\n\n\nfunction withLayoutItem(layout\n/*: Layout*/\n, itemKey\n/*: string*/\n, cb\n/*: LayoutItem => LayoutItem*/\n)\n/*: [Layout, ?LayoutItem]*/\n{\n  let item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a\n/*: ReactChildren*/\n, b\n/*: ReactChildren*/\n)\n/*: boolean*/\n{\n  return (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c === null || c === void 0 ? void 0 : c.key), _react.default.Children.map(b, c => c === null || c === void 0 ? void 0 : c.key)) && (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c === null || c === void 0 ? void 0 : c.props[\"data-grid\"]), _react.default.Children.map(b, c => c === null || c === void 0 ? void 0 : c.props[\"data-grid\"]));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\n\nconst fastRGLPropsEqual\n/*: FastRGLPropsEqual*/\n= require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\n\nfunction fastPositionEqual(a\n/*: Position*/\n, b\n/*: Position*/\n)\n/*: boolean*/\n{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @param  {Boolean} allowOverlap When `true`, allows overlapping grid items.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout); // We go through the items by row and column.\n\n  const sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  const out = Array(layout.length);\n\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted, allowOverlap); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nconst heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/\n, item\n/*: LayoutItem*/\n, moveToCoord\n/*: number*/\n, axis\n/*: \"x\" | \"y\"*/\n) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout.map(layoutItem => {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\n\nfunction compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, fullLayout\n/*: Layout*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: LayoutItem*/\n{\n  const compactV = compactType === \"vertical\";\n  const compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  let collides; // Checking the compactType null value to avoid breaking the layout when overlapping is allowed.\n\n  while ((collides = getFirstCollision(compareWith, l)) && !(compactType === null && allowOverlap)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++; // ALso move element as left as we can\n\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        l.x--;\n      }\n    }\n  } // Ensure that there are no negative positions\n\n\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  const collidesWith = getStatics(layout);\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nfunction getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(l => collides(l, layoutItem));\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(l => l.static);\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: ?number*/\n, y\n/*: ?number*/\n, isUserAction\n/*: ?boolean*/\n, preventCollision\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  const oldX = l.x;\n  const oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  const collisions = getAllCollisions(sorted, l);\n  const hasCollisions = collisions.length > 0; // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  } // Move each item that collides away from this element.\n\n\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  const compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  const compactV = compactType === \"vertical\";\n  const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    const fakeItem\n    /*: LayoutItem*/\n    = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n    const firstCollision = getFirstCollision(layout, fakeItem);\n    const collisionNorth = firstCollision && firstCollision.y + firstCollision.h > collidesWith.y;\n    const collisionWest = firstCollision && collidesWith.x + collidesWith.w > firstCollision.x; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!firstCollision) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactV) {\n      return moveElement(layout, itemToMove, undefined, collidesWith.y + 1, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactType == null) {\n      collidesWith.y = itemToMove.y;\n      itemToMove.y = itemToMove.y + itemToMove.h;\n      return layout;\n    } else if (collisionWest && compactH) {\n      return moveElement(layout, collidesWith, itemToMove.x, undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  const newX = compactH ? itemToMove.x + 1 : undefined;\n  const newY = compactV ? itemToMove.y + 1 : undefined;\n\n  if (newX == null && newY == null) {\n    return layout;\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + \"%\";\n}\n/**\n * Helper functions to constrain dimensions of a GridItem\n */\n\n\nconst constrainWidth = (left\n/*: number*/\n, currentWidth\n/*: number*/\n, newWidth\n/*: number*/\n, containerWidth\n/*: number*/\n) => {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n};\n\nconst constrainHeight = (top\n/*: number*/\n, currentHeight\n/*: number*/\n, newHeight\n/*: number*/\n) => {\n  return top < 0 ? currentHeight : newHeight;\n};\n\nconst constrainLeft = (left\n/*: number*/\n) => Math.max(0, left);\n\nconst constrainTop = (top\n/*: number*/\n) => Math.max(0, top);\n\nconst resizeNorth = (currentSize, _ref, _containerWidth) => {\n  let {\n    left,\n    height,\n    width\n  } = _ref;\n  const top = currentSize.top - (height - currentSize.height);\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\n\nconst resizeEast = (currentSize, _ref2, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref2;\n  return {\n    top,\n    height,\n    width: constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    left: constrainLeft(left)\n  };\n};\n\nconst resizeWest = (currentSize, _ref3, containerWidth) => {\n  let {\n    top,\n    height,\n    width\n  } = _ref3;\n  const left = currentSize.left - (width - currentSize.width);\n  return {\n    height,\n    width: left < 0 ? currentSize.width : constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    top: constrainTop(top),\n    left: constrainLeft(left)\n  };\n};\n\nconst resizeSouth = (currentSize, _ref4, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref4;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\n\nconst resizeNorthEast = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\n\nconst resizeNorthWest = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\n\nconst resizeSouthEast = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\n\nconst resizeSouthWest = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\n\nconst ordinalResizeHandlerMap = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n/**\n * Helper for clamping width and position when resizing an item.\n */\n\nfunction resizeItemInDirection(direction\n/*: ResizeHandleAxis*/\n, currentSize\n/*: Position*/\n, newSize\n/*: Position*/\n, containerWidth\n/*: number*/\n)\n/*: Position*/\n{\n  const ordinalHandler = ordinalResizeHandlerMap[direction]; // Shouldn't be possible given types; that said, don't fail hard\n\n  if (!ordinalHandler) return newSize;\n  return ordinalHandler(currentSize, { ...currentSize,\n    ...newSize\n  }, containerWidth);\n}\n\nfunction setTransform(_ref5\n/*:: */\n)\n/*: Object*/\n{\n  let {\n    top,\n    left,\n    width,\n    height\n  }\n  /*: Position*/\n  = _ref5\n  /*: Position*/\n  ; // Replace unitless items with px\n\n  const translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref6\n/*:: */\n)\n/*: Object*/\n{\n  let {\n    top,\n    left,\n    width,\n    height\n  }\n  /*: Position*/\n  = _ref6\n  /*: Position*/\n  ;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/\n, children\n/*: ReactChildren*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  const layout\n  /*: LayoutItem[]*/\n  = [];\n\n  _react.default.Children.forEach(children, (child\n  /*: ReactElement<any>*/\n  ) => {\n    // Child may not exist\n    if ((child === null || child === void 0 ? void 0 : child.key) == null) return;\n    const exists = getLayoutItem(initialLayout, String(child.key));\n    const g = child.props[\"data-grid\"]; // Don't overwrite the layout item if it's already in the initial layout.\n    // If it has a `data-grid` property, prefer that over what's in the layout.\n\n    if (exists && g == null) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      // Hey, this item has a data-grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        } // FIXME clone not really necessary here\n\n\n        layout.push(cloneLayoutItem({ ...g,\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  }); // Correct the layout.\n\n\n  const correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout\n/*: Layout*/\n)\n/*: void*/\n{\n  let contextName\n  /*: string*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  const subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n\n    for (let j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n  }\n} // Legacy support for verticalCompact: false\n\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\n)\n/*: CompactType*/\n{\n  const {\n    verticalCompact,\n    compactType\n  } = props || {};\n  return verticalCompact === false ? null : compactType;\n}\n\nfunction log() {\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  console.log(...arguments);\n}\n\nconst noop = () => {};\n\nexports.noop = noop;","map":{"version":3,"sources":["/Users/viviengeschwind/Projects/Website/website-professional/node_modules/react-grid-layout/build/utils.js"],"names":["Object","defineProperty","exports","value","bottom","childrenEqual","cloneLayout","cloneLayoutItem","collides","compact","compactItem","compactType","correctBounds","fastPositionEqual","fastRGLPropsEqual","getAllCollisions","getFirstCollision","getLayoutItem","getStatics","modifyLayout","moveElement","moveElementAwayFromCollision","noop","perc","resizeItemInDirection","setTopLeft","setTransform","sortLayoutItems","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","synchronizeLayoutWithChildren","validateLayout","withLayoutItem","_fastEquals","require","_react","_interopRequireDefault","obj","__esModule","default","isProduction","process","env","NODE_ENV","DEBUG","layout","max","bottomY","i","len","length","y","h","newLayout","Array","layoutItem","itemKey","cb","item","w","x","minW","maxW","minH","maxH","moved","Boolean","static","isDraggable","isResizable","resizeHandles","isBounded","a","b","deepEqual","Children","map","c","key","props","left","top","width","height","l1","l2","cols","allowOverlap","compareWith","sorted","out","l","push","indexOf","heightWidth","resolveCompactionCollision","moveToCoord","axis","sizeProp","itemIndex","otherItem","fullLayout","compactV","compactH","Math","min","bounds","collidesWith","id","filter","isUserAction","preventCollision","log","concat","String","oldX","oldY","movingUp","reverse","collisions","hasCollisions","collision","itemToMove","fakeItem","firstCollision","collisionNorth","collisionWest","undefined","newX","newY","num","constrainWidth","currentWidth","newWidth","containerWidth","constrainHeight","currentHeight","newHeight","constrainLeft","constrainTop","resizeNorth","currentSize","_ref","_containerWidth","resizeEast","_ref2","resizeWest","_ref3","resizeSouth","_ref4","resizeNorthEast","arguments","resizeNorthWest","resizeSouthEast","resizeSouthWest","ordinalResizeHandlerMap","n","ne","e","se","s","sw","nw","direction","newSize","ordinalHandler","_ref5","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","_ref6","slice","sort","initialLayout","children","forEach","child","exists","g","correctedLayout","contextName","subProps","isArray","Error","j","verticalCompact","console"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.resizeItemInDirection = resizeItemInDirection;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\nvar _fastEquals = require(\"fast-equals\");\nvar _react = _interopRequireDefault(require(\"react\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: export type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";*/\n/*:: export type LayoutItem = {\n  w: number,\n  h: number,\n  x: number,\n  y: number,\n  i: string,\n  minW?: number,\n  minH?: number,\n  maxW?: number,\n  maxH?: number,\n  moved?: boolean,\n  static?: boolean,\n  isDraggable?: ?boolean,\n  isResizable?: ?boolean,\n  resizeHandles?: Array<ResizeHandleAxis>,\n  isBounded?: ?boolean\n};*/\n/*:: export type Layout = $ReadOnlyArray<LayoutItem>;*/\n/*:: export type Position = {\n  left: number,\n  top: number,\n  width: number,\n  height: number\n};*/\n/*:: export type ReactDraggableCallbackData = {\n  node: HTMLElement,\n  x?: number,\n  y?: number,\n  deltaX: number,\n  deltaY: number,\n  lastX?: number,\n  lastY?: number\n};*/\n/*:: export type PartialPosition = { left: number, top: number };*/\n/*:: export type DroppingPosition = { left: number, top: number, e: Event };*/\n/*:: export type Size = { width: number, height: number };*/\n/*:: export type GridDragEvent = {\n  e: Event,\n  node: HTMLElement,\n  newPosition: PartialPosition\n};*/\n/*:: export type GridResizeEvent = {\n  e: Event,\n  node: HTMLElement,\n  size: Size,\n  handle: string\n};*/\n/*:: export type DragOverEvent = MouseEvent & {\n  nativeEvent: {\n    layerX: number,\n    layerY: number,\n    ...Event\n  }\n};*/\n/*:: export type Pick<FromType, Properties: { [string]: 0 }> = $Exact<\n  $ObjMapi<Properties, <K, V>(k: K, v: V) => $ElementType<FromType, K>>\n>;*/\n// Helpful port from TS\n/*:: type REl = ReactElement<any>;*/\n/*:: export type ReactChildren = ReactChildrenArray<REl>;*/\n/*:: export type EventCallback = (\n  Layout,\n  oldItem: ?LayoutItem,\n  newItem: ?LayoutItem,\n  placeholder: ?LayoutItem,\n  Event,\n  ?HTMLElement\n) => void;*/\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\n/*:: export type CompactType = ?(\"horizontal\" | \"vertical\");*/\nconst isProduction = process.env.NODE_ENV === \"production\";\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nfunction bottom(layout /*: Layout*/) /*: number*/{\n  let max = 0,\n    bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\nfunction cloneLayout(layout /*: Layout*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n}\n\n// Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\nfunction modifyLayout(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n  return newLayout;\n}\n\n// Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\nfunction withLayoutItem(layout /*: Layout*/, itemKey /*: string*/, cb /*: LayoutItem => LayoutItem*/) /*: [Layout, ?LayoutItem]*/{\n  let item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n}\n\n// Fast path to cloning, since this is monomorphic\nfunction cloneLayoutItem(layoutItem /*: LayoutItem*/) /*: LayoutItem*/{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nfunction childrenEqual(a /*: ReactChildren*/, b /*: ReactChildren*/) /*: boolean*/{\n  return (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c === null || c === void 0 ? void 0 : c.key), _react.default.Children.map(b, c => c === null || c === void 0 ? void 0 : c.key)) && (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c === null || c === void 0 ? void 0 : c.props[\"data-grid\"]), _react.default.Children.map(b, c => c === null || c === void 0 ? void 0 : c.props[\"data-grid\"]));\n}\n\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\nconst fastRGLPropsEqual /*: FastRGLPropsEqual*/ = require(\"./fastRGLPropsEqual\");\n\n// Like the above, but a lot simpler.\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\nfunction fastPositionEqual(a /*: Position*/, b /*: Position*/) /*: boolean*/{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nfunction collides(l1 /*: LayoutItem*/, l2 /*: LayoutItem*/) /*: boolean*/{\n  if (l1.i === l2.i) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @param  {Boolean} allowOverlap When `true`, allows overlapping grid items.\n * @return {Array}       Compacted Layout.\n */\nfunction compact(layout /*: Layout*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  const sorted = sortLayoutItems(layout, compactType);\n  // Holding for new items.\n  const out = Array(layout.length);\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]);\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted, allowOverlap);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(sorted[i])] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n  return out;\n}\nconst heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(layout /*: Layout*/, item /*: LayoutItem*/, moveToCoord /*: number*/, axis /*: \"x\" | \"y\"*/) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout.map(layoutItem => {\n    return layoutItem.i;\n  }).indexOf(item.i);\n\n  // Go through each item we collide with.\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    // Ignore static items\n    if (otherItem.static) continue;\n\n    // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n    if (otherItem.y > item.y + item.h) break;\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n  item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\nfunction compactItem(compareWith /*: Layout*/, l /*: LayoutItem*/, compactType /*: CompactType*/, cols /*: number*/, fullLayout /*: Layout*/, allowOverlap /*: ?boolean*/) /*: LayoutItem*/{\n  const compactV = compactType === \"vertical\";\n  const compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  let collides;\n  // Checking the compactType null value to avoid breaking the layout when overlapping is allowed.\n  while ((collides = getFirstCollision(compareWith, l)) && !(compactType === null && allowOverlap)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    }\n    // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n      // ALso move element as left as we can\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        l.x--;\n      }\n    }\n  }\n\n  // Ensure that there are no negative positions\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nfunction correctBounds(layout /*: Layout*/, bounds /*: { cols: number }*/) /*: Layout*/{\n  const collidesWith = getStatics(layout);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nfunction getLayoutItem(layout /*: Layout*/, id /*: string*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nfunction getFirstCollision(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nfunction getAllCollisions(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nfunction getStatics(layout /*: Layout*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nfunction moveElement(layout /*: Layout*/, l /*: LayoutItem*/, x /*: ?number*/, y /*: ?number*/, isUserAction /*: ?boolean*/, preventCollision /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout;\n\n  // Short-circuit if nothing to do.\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  const oldX = l.x;\n  const oldY = l.y;\n\n  // This is quite a bit faster than extending the object\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false;\n  // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n  if (movingUp) sorted = sorted.reverse();\n  const collisions = getAllCollisions(sorted, l);\n  const hasCollisions = collisions.length > 0;\n\n  // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  }\n\n  // Move each item that collides away from this element.\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\"));\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n  return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nfunction moveElementAwayFromCollision(layout /*: Layout*/, collidesWith /*: LayoutItem*/, itemToMove /*: LayoutItem*/, isUserAction /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/) /*: Layout*/{\n  const compactH = compactType === \"horizontal\";\n  // Compact vertically if not set to horizontal\n  const compactV = compactType === \"vertical\";\n  const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false;\n\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    const fakeItem /*: LayoutItem*/ = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n    const firstCollision = getFirstCollision(layout, fakeItem);\n    const collisionNorth = firstCollision && firstCollision.y + firstCollision.h > collidesWith.y;\n    const collisionWest = firstCollision && collidesWith.x + collidesWith.w > firstCollision.x;\n\n    // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n    if (!firstCollision) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactV) {\n      return moveElement(layout, itemToMove, undefined, collidesWith.y + 1, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactType == null) {\n      collidesWith.y = itemToMove.y;\n      itemToMove.y = itemToMove.y + itemToMove.h;\n      return layout;\n    } else if (collisionWest && compactH) {\n      return moveElement(layout, collidesWith, itemToMove.x, undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n  const newX = compactH ? itemToMove.x + 1 : undefined;\n  const newY = compactV ? itemToMove.y + 1 : undefined;\n  if (newX == null && newY == null) {\n    return layout;\n  }\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nfunction perc(num /*: number*/) /*: string*/{\n  return num * 100 + \"%\";\n}\n\n/**\n * Helper functions to constrain dimensions of a GridItem\n */\nconst constrainWidth = (left /*: number*/, currentWidth /*: number*/, newWidth /*: number*/, containerWidth /*: number*/) => {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n};\nconst constrainHeight = (top /*: number*/, currentHeight /*: number*/, newHeight /*: number*/) => {\n  return top < 0 ? currentHeight : newHeight;\n};\nconst constrainLeft = (left /*: number*/) => Math.max(0, left);\nconst constrainTop = (top /*: number*/) => Math.max(0, top);\nconst resizeNorth = (currentSize, _ref, _containerWidth) => {\n  let {\n    left,\n    height,\n    width\n  } = _ref;\n  const top = currentSize.top - (height - currentSize.height);\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeEast = (currentSize, _ref2, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref2;\n  return {\n    top,\n    height,\n    width: constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    left: constrainLeft(left)\n  };\n};\nconst resizeWest = (currentSize, _ref3, containerWidth) => {\n  let {\n    top,\n    height,\n    width\n  } = _ref3;\n  const left = currentSize.left - (width - currentSize.width);\n  return {\n    height,\n    width: left < 0 ? currentSize.width : constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    top: constrainTop(top),\n    left: constrainLeft(left)\n  };\n};\nconst resizeSouth = (currentSize, _ref4, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref4;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeNorthEast = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeNorthWest = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthEast = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthWest = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst ordinalResizeHandlerMap = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n\n/**\n * Helper for clamping width and position when resizing an item.\n */\nfunction resizeItemInDirection(direction /*: ResizeHandleAxis*/, currentSize /*: Position*/, newSize /*: Position*/, containerWidth /*: number*/) /*: Position*/{\n  const ordinalHandler = ordinalResizeHandlerMap[direction];\n  // Shouldn't be possible given types; that said, don't fail hard\n  if (!ordinalHandler) return newSize;\n  return ordinalHandler(currentSize, {\n    ...currentSize,\n    ...newSize\n  }, containerWidth);\n}\nfunction setTransform(_ref5 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref5 /*: Position*/;\n  // Replace unitless items with px\n  const translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\nfunction setTopLeft(_ref6 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref6 /*: Position*/;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nfunction sortLayoutItems(layout /*: Layout*/, compactType /*: CompactType*/) /*: Layout*/{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByRowCol(layout /*: Layout*/) /*: Layout*/{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByColRow(layout /*: Layout*/) /*: Layout*/{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nfunction synchronizeLayoutWithChildren(initialLayout /*: Layout*/, children /*: ReactChildren*/, cols /*: number*/, compactType /*: CompactType*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  initialLayout = initialLayout || [];\n\n  // Generate one layout item per child.\n  const layout /*: LayoutItem[]*/ = [];\n  _react.default.Children.forEach(children, (child /*: ReactElement<any>*/) => {\n    // Child may not exist\n    if ((child === null || child === void 0 ? void 0 : child.key) == null) return;\n    const exists = getLayoutItem(initialLayout, String(child.key));\n    const g = child.props[\"data-grid\"];\n    // Don't overwrite the layout item if it's already in the initial layout.\n    // If it has a `data-grid` property, prefer that over what's in the layout.\n    if (exists && g == null) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      // Hey, this item has a data-grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          ...g,\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  });\n\n  // Correct the layout.\n  const correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nfunction validateLayout(layout /*: Layout*/) /*: void*/{\n  let contextName /*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  const subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n    for (let j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n  }\n}\n\n// Legacy support for verticalCompact: false\nfunction compactType(props /*: ?{ verticalCompact: boolean, compactType: CompactType }*/) /*: CompactType*/{\n  const {\n    verticalCompact,\n    compactType\n  } = props || {};\n  return verticalCompact === false ? null : compactType;\n}\nfunction log() {\n  if (!DEBUG) return;\n  // eslint-disable-next-line no-console\n  console.log(...arguments);\n}\nconst noop = () => {};\nexports.noop = noop;"]},"metadata":{},"sourceType":"script"}