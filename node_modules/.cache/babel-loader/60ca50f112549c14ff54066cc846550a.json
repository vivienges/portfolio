{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\n\nvar _shims = require(\"./shims\");\n\nvar _domFns = require(\"./domFns\");\n/*:: import type Draggable from '../Draggable';*/\n\n/*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/\n\n/*:: import type DraggableCore from '../DraggableCore';*/\n\n\nfunction getBoundPosition(draggable\n/*: Draggable*/\n, x\n/*: number*/\n, y\n/*: number*/\n)\n/*: [number, number]*/\n{\n  // If no bounds, short-circuit and move on\n  if (!draggable.props.bounds) return [x, y]; // Clone new bounds\n\n  let {\n    bounds\n  } = draggable.props;\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n  const node = findDOMNode(draggable);\n\n  if (typeof bounds === 'string') {\n    const {\n      ownerDocument\n    } = node;\n    const ownerWindow = ownerDocument.defaultView;\n    let boundNode;\n\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      boundNode = ownerDocument.querySelector(bounds);\n    }\n\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n    }\n\n    const boundNodeEl\n    /*: HTMLElement*/\n    = boundNode; // for Flow, can't seem to refine correctly\n\n    const nodeStyle = ownerWindow.getComputedStyle(node);\n    const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl); // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n\n    bounds = {\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n      right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n      bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n    };\n  } // Keep x and y below right and bottom limits...\n\n\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom); // But above left and top limits.\n\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n  return [x, y];\n}\n\nfunction snapToGrid(grid\n/*: [number, number]*/\n, pendingX\n/*: number*/\n, pendingY\n/*: number*/\n)\n/*: [number, number]*/\n{\n  const x = Math.round(pendingX / grid[0]) * grid[0];\n  const y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\n\nfunction canDragX(draggable\n/*: Draggable*/\n)\n/*: boolean*/\n{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n}\n\nfunction canDragY(draggable\n/*: Draggable*/\n)\n/*: boolean*/\n{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n} // Get {x, y} positions from event.\n\n\nfunction getControlPosition(e\n/*: MouseTouchEvent*/\n, touchIdentifier\n/*: ?number*/\n, draggableCore\n/*: DraggableCore*/\n)\n/*: ?ControlPosition*/\n{\n  const touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n\n  const node = findDOMNode(draggableCore); // User can provide an offsetParent if desired.\n\n  const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n} // Create an data object exposed by <DraggableCore>'s events\n\n\nfunction createCoreData(draggable\n/*: DraggableCore*/\n, x\n/*: number*/\n, y\n/*: number*/\n)\n/*: DraggableData*/\n{\n  const isStart = !(0, _shims.isNum)(draggable.lastX);\n  const node = findDOMNode(draggable);\n\n  if (isStart) {\n    // If this is our first move, use the x and y as last coords.\n    return {\n      node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x,\n      y\n    };\n  } else {\n    // Otherwise calculate proper values.\n    return {\n      node,\n      deltaX: x - draggable.lastX,\n      deltaY: y - draggable.lastY,\n      lastX: draggable.lastX,\n      lastY: draggable.lastY,\n      x,\n      y\n    };\n  }\n} // Create an data exposed by <Draggable>'s events\n\n\nfunction createDraggableData(draggable\n/*: Draggable*/\n, coreData\n/*: DraggableData*/\n)\n/*: DraggableData*/\n{\n  const scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + coreData.deltaX / scale,\n    y: draggable.state.y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n} // A lot faster than stringify/parse\n\n\nfunction cloneBounds(bounds\n/*: Bounds*/\n)\n/*: Bounds*/\n{\n  return {\n    left: bounds.left,\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom\n  };\n}\n\nfunction findDOMNode(draggable\n/*: Draggable | DraggableCore*/\n)\n/*: HTMLElement*/\n{\n  const node = draggable.findDOMNode();\n\n  if (!node) {\n    throw new Error('<DraggableCore>: Unmounted during event!');\n  } // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n\n\n  return node;\n}","map":{"version":3,"sources":["/Users/viviengeschwind/Projects/Website/website-professional/node_modules/react-draggable/build/cjs/utils/positionFns.js"],"names":["Object","defineProperty","exports","value","canDragX","canDragY","createCoreData","createDraggableData","getBoundPosition","getControlPosition","snapToGrid","_shims","require","_domFns","draggable","x","y","props","bounds","cloneBounds","node","findDOMNode","ownerDocument","ownerWindow","defaultView","boundNode","parentNode","querySelector","HTMLElement","Error","boundNodeEl","nodeStyle","getComputedStyle","boundNodeStyle","left","offsetLeft","int","paddingLeft","marginLeft","top","offsetTop","paddingTop","marginTop","right","innerWidth","outerWidth","paddingRight","marginRight","bottom","innerHeight","outerHeight","paddingBottom","marginBottom","isNum","Math","min","max","grid","pendingX","pendingY","round","axis","e","touchIdentifier","draggableCore","touchObj","getTouch","offsetParent","body","offsetXYFromParent","scale","isStart","lastX","deltaX","deltaY","lastY","coreData","state"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\nvar _shims = require(\"./shims\");\nvar _domFns = require(\"./domFns\");\n/*:: import type Draggable from '../Draggable';*/\n/*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/\n/*:: import type DraggableCore from '../DraggableCore';*/\nfunction getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/{\n  // If no bounds, short-circuit and move on\n  if (!draggable.props.bounds) return [x, y];\n\n  // Clone new bounds\n  let {\n    bounds\n  } = draggable.props;\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n  const node = findDOMNode(draggable);\n  if (typeof bounds === 'string') {\n    const {\n      ownerDocument\n    } = node;\n    const ownerWindow = ownerDocument.defaultView;\n    let boundNode;\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      boundNode = ownerDocument.querySelector(bounds);\n    }\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n    }\n    const boundNodeEl /*: HTMLElement*/ = boundNode; // for Flow, can't seem to refine correctly\n    const nodeStyle = ownerWindow.getComputedStyle(node);\n    const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n    bounds = {\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n      right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n      bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n    };\n  }\n\n  // Keep x and y below right and bottom limits...\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);\n\n  // But above left and top limits.\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n  return [x, y];\n}\nfunction snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/{\n  const x = Math.round(pendingX / grid[0]) * grid[0];\n  const y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\nfunction canDragX(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n}\nfunction canDragY(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n}\n\n// Get {x, y} positions from event.\nfunction getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/{\n  const touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n  const node = findDOMNode(draggableCore);\n  // User can provide an offsetParent if desired.\n  const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n}\n\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/{\n  const isStart = !(0, _shims.isNum)(draggable.lastX);\n  const node = findDOMNode(draggable);\n  if (isStart) {\n    // If this is our first move, use the x and y as last coords.\n    return {\n      node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x,\n      y\n    };\n  } else {\n    // Otherwise calculate proper values.\n    return {\n      node,\n      deltaX: x - draggable.lastX,\n      deltaY: y - draggable.lastY,\n      lastX: draggable.lastX,\n      lastY: draggable.lastY,\n      x,\n      y\n    };\n  }\n}\n\n// Create an data exposed by <Draggable>'s events\nfunction createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/{\n  const scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + coreData.deltaX / scale,\n    y: draggable.state.y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n}\n\n// A lot faster than stringify/parse\nfunction cloneBounds(bounds /*: Bounds*/) /*: Bounds*/{\n  return {\n    left: bounds.left,\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom\n  };\n}\nfunction findDOMNode(draggable /*: Draggable | DraggableCore*/) /*: HTMLElement*/{\n  const node = draggable.findDOMNode();\n  if (!node) {\n    throw new Error('<DraggableCore>: Unmounted during event!');\n  }\n  // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n  return node;\n}"]},"metadata":{},"sourceType":"script"}