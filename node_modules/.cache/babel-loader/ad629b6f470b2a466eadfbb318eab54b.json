{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcGridItemWHPx = calcGridItemWHPx;\nexports.calcWH = calcWH;\nexports.calcXY = calcXY;\nexports.clamp = clamp;\n/*:: import type { Position } from \"./utils\";*/\n\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\n\nfunction calcGridColWidth(positionParams\n/*: PositionParams*/\n)\n/*: number*/\n{\n  const {\n    margin,\n    containerPadding,\n    containerWidth,\n    cols\n  } = positionParams;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n} // This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\n\n\nfunction calcGridItemWHPx(gridUnits\n/*: number*/\n, colOrRowSize\n/*: number*/\n, marginPx\n/*: number*/\n)\n/*: number*/\n{\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\n\n\nfunction calcGridItemPosition(positionParams\n/*: PositionParams*/\n, x\n/*: number*/\n, y\n/*: number*/\n, w\n/*: number*/\n, h\n/*: number*/\n, state\n/*: ?Object*/\n)\n/*: Position*/\n{\n  const {\n    margin,\n    containerPadding,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n  const out = {}; // If resizing, use the exact width and height as returned from resizing callbacks.\n\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  } // Otherwise, calculate from grid units.\n  else {\n      out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n      out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n    } // If dragging, use the exact width and height as returned from dragging callbacks.\n\n\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } else if (state && state.resizing && typeof state.resizing.top === \"number\" && typeof state.resizing.left === \"number\") {\n    out.top = Math.round(state.resizing.top);\n    out.left = Math.round(state.resizing.left);\n  } // Otherwise, calculate from grid units.\n  else {\n      out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n      out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n    }\n\n  return out;\n}\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\n\n\nfunction calcXY(positionParams\n/*: PositionParams*/\n, top\n/*: number*/\n, left\n/*: number*/\n, w\n/*: number*/\n, h\n/*: number*/\n)\n/*: { x: number, y: number }*/\n{\n  const {\n    margin,\n    cols,\n    rowHeight,\n    maxRows\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams); // left = colWidth * x + margin * (x + 1)\n  // l = cx + m(x+1)\n  // l = cx + mx + m\n  // l - m = cx + mx\n  // l - m = x(c + m)\n  // (l - m) / (c + m) = x\n  // x = (left - margin) / (coldWidth + margin)\n\n  let x = Math.round((left - margin[0]) / (colWidth + margin[0]));\n  let y = Math.round((top - margin[1]) / (rowHeight + margin[1])); // Capping\n\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n  return {\n    x,\n    y\n  };\n}\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @param {String} handle Resize Handle.\n * @return {Object}                         w, h as grid units.\n */\n\n\nfunction calcWH(positionParams\n/*: PositionParams*/\n, width\n/*: number*/\n, height\n/*: number*/\n, x\n/*: number*/\n, y\n/*: number*/\n, handle\n/*: string*/\n)\n/*: { w: number, h: number }*/\n{\n  const {\n    margin,\n    maxRows,\n    cols,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams); // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n\n  let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  let h = Math.round((height + margin[1]) / (rowHeight + margin[1])); // Capping\n\n  let _w = clamp(w, 0, cols - x);\n\n  let _h = clamp(h, 0, maxRows - y);\n\n  if ([\"sw\", \"w\", \"nw\"].indexOf(handle) !== -1) {\n    _w = clamp(w, 0, cols);\n  }\n\n  if ([\"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n    _h = clamp(h, 0, maxRows);\n  }\n\n  return {\n    w: _w,\n    h: _h\n  };\n} // Similar to _.clamp\n\n\nfunction clamp(num\n/*: number*/\n, lowerBound\n/*: number*/\n, upperBound\n/*: number*/\n)\n/*: number*/\n{\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}","map":{"version":3,"sources":["/Users/viviengeschwind/Projects/Website/website-professional/node_modules/react-grid-layout/build/calculateUtils.js"],"names":["Object","defineProperty","exports","value","calcGridColWidth","calcGridItemPosition","calcGridItemWHPx","calcWH","calcXY","clamp","positionParams","margin","containerPadding","containerWidth","cols","gridUnits","colOrRowSize","marginPx","Number","isFinite","Math","round","max","x","y","w","h","state","rowHeight","colWidth","out","resizing","width","height","dragging","top","left","maxRows","handle","_w","_h","indexOf","num","lowerBound","upperBound","min"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcGridItemWHPx = calcGridItemWHPx;\nexports.calcWH = calcWH;\nexports.calcXY = calcXY;\nexports.clamp = clamp;\n/*:: import type { Position } from \"./utils\";*/\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\nfunction calcGridColWidth(positionParams /*: PositionParams*/) /*: number*/{\n  const {\n    margin,\n    containerPadding,\n    containerWidth,\n    cols\n  } = positionParams;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n}\n\n// This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\nfunction calcGridItemWHPx(gridUnits /*: number*/, colOrRowSize /*: number*/, marginPx /*: number*/) /*: number*/{\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\n\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\nfunction calcGridItemPosition(positionParams /*: PositionParams*/, x /*: number*/, y /*: number*/, w /*: number*/, h /*: number*/, state /*: ?Object*/) /*: Position*/{\n  const {\n    margin,\n    containerPadding,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n  const out = {};\n\n  // If resizing, use the exact width and height as returned from resizing callbacks.\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n    out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n  }\n\n  // If dragging, use the exact width and height as returned from dragging callbacks.\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } else if (state && state.resizing && typeof state.resizing.top === \"number\" && typeof state.resizing.left === \"number\") {\n    out.top = Math.round(state.resizing.top);\n    out.left = Math.round(state.resizing.left);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n    out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n  }\n  return out;\n}\n\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\nfunction calcXY(positionParams /*: PositionParams*/, top /*: number*/, left /*: number*/, w /*: number*/, h /*: number*/) /*: { x: number, y: number }*/{\n  const {\n    margin,\n    cols,\n    rowHeight,\n    maxRows\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // left = colWidth * x + margin * (x + 1)\n  // l = cx + m(x+1)\n  // l = cx + mx + m\n  // l - m = cx + mx\n  // l - m = x(c + m)\n  // (l - m) / (c + m) = x\n  // x = (left - margin) / (coldWidth + margin)\n  let x = Math.round((left - margin[0]) / (colWidth + margin[0]));\n  let y = Math.round((top - margin[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n  return {\n    x,\n    y\n  };\n}\n\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @param {String} handle Resize Handle.\n * @return {Object}                         w, h as grid units.\n */\nfunction calcWH(positionParams /*: PositionParams*/, width /*: number*/, height /*: number*/, x /*: number*/, y /*: number*/, handle /*: string*/) /*: { w: number, h: number }*/{\n  const {\n    margin,\n    maxRows,\n    cols,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n  let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  let h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  let _w = clamp(w, 0, cols - x);\n  let _h = clamp(h, 0, maxRows - y);\n  if ([\"sw\", \"w\", \"nw\"].indexOf(handle) !== -1) {\n    _w = clamp(w, 0, cols);\n  }\n  if ([\"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n    _h = clamp(h, 0, maxRows);\n  }\n  return {\n    w: _w,\n    h: _h\n  };\n}\n\n// Similar to _.clamp\nfunction clamp(num /*: number*/, lowerBound /*: number*/, upperBound /*: number*/) /*: number*/{\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}"]},"metadata":{},"sourceType":"script"}